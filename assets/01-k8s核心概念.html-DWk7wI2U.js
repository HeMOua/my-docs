import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as l,d as t,o,r}from"./app-Gj0sH8Bx.js";const n="/assets/image-20240707175425959-FkIbhAl6.png",u="/assets/architecture-CQpivhhj.png",d="/assets/image-20240707193844173-y_uivdcR.png",p="/assets/image-20240707193900375-CVy0J3VP.png",c="/assets/kubernetes-layers-Do2wwVcN.jpg",h="/assets/image-20240728204453536-pKH2Ke1V.png",m="/assets/image-20240731224612631-LJG0mi6k.png",b={};function g(k,e){const i=r("Mermaid");return o(),s("div",null,[e[0]||(e[0]=l('<h1 id="k8s核心概念" tabindex="-1"><a class="header-anchor" href="#k8s核心概念"><span>k8s核心概念</span></a></h1><h2 id="认识k8s" tabindex="-1"><a class="header-anchor" href="#认识k8s"><span>认识k8s</span></a></h2><h3 id="什么是k8s" tabindex="-1"><a class="header-anchor" href="#什么是k8s"><span>什么是k8s</span></a></h3><p><strong>Kubernetes</strong> 是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful），Kubernetes 提供了应用部署，规划，更新，维护的一种机制。是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。</p><p>kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：</p><ul><li>自我修复：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器</li><li>弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整</li><li>服务发现：服务可以通过自动发现的形式找到它所依赖的服务</li><li>负载均衡：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</li><li>版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li><li>存储编排：可以根据容器自身的需求自动创建存储卷</li></ul><p>简单来说 k8s 就是一种管理容器化应用的平台。</p><blockquote><p><strong>Kubernetes</strong> 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。</p></blockquote><h3 id="为什么需要k8s" tabindex="-1"><a class="header-anchor" href="#为什么需要k8s"><span>为什么需要k8s</span></a></h3><p>在部署应用程序的方式上，主要经历了三个时代：</p><ul><li><p>传统部署：互联网早期，会直接将应用程序部署在物理机上</p><ul><li><p>优点：简单，不需要其它技术的参与</p></li><li><p>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</p></li></ul></li><li><p>虚拟化部署：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p><ul><li>优点：程序环境不会相互产生影响，提供了一定程度的安全性</li><li>缺点：增加了操作系统，浪费了部分资源</li></ul></li><li><p>容器化部署：可以理解为轻量级的虚拟化，直接共享主机硬件资源，只是通过系统提供的命名空间等技术实现资源隔离，损耗更小，且效率更高。</p><ul><li>优点： <ul><li>可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</li><li>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</li><li>容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</li></ul></li></ul></li></ul><h3 id="企业级容器调度平台" tabindex="-1"><a class="header-anchor" href="#企业级容器调度平台"><span>企业级容器调度平台</span></a></h3><ul><li>Mesos <ul><li>基本概念：Mesos 是一个分布式调度系统内核，早于 Docker 产生，Mesos 作为资源管理器，从 DC/OS (数据中心操作系统)的角度提供资源视图。主/从结构工作模式，主节点分配任务，并用从节点上的 Executor 负责执行，通过 Zookeeper 给主节点提供服务注册、服务发现功能。通过 Framework Marathon 提供容器调度的能力。</li><li>优势： <ul><li>经过时间的检验，作为资源管理器的 Apache Mesos 在容器之前就已经出现很久了，支持运行容器化化和非容器化的工作负载。可以支持应用程序的健康检查，开放的架构。支持多个框架和多个调度器，通过不同的 Framework 可以运行 Haddop/Spark/MPI等多种不同的任务。</li><li>支持超大型规模的节点管理，模拟测试支持超过 5w+ 节点，在大规模上拥有较大优势。</li></ul></li></ul></li><li>Swarm <ul><li>基本概念：Docker Swarm 是一个由 Docker 开发的调度框架。由 Docker 自身开发的好处之一就是标准 Docker API 的使用，Swarm 由多个代理（Agent）组成，把这些代理称之为节点（Node）。这些节点就是主机，这些主机在启动 Docker Daemon 的时候就会打开相应的端口，以此支持 Docker 远程 API。这些机器会根据 Swarm 调度器分配给它们的任务，拉取和运行不同的镜像。</li><li>优势： <ul><li>从 Docker1.12 版本开始，Swarm 随 Docker 一起默认安装发布。由于随 Docker 引擎一起发布，无需额外安装，配置简单。支持服务注册、服务发现，内置 Overlay Network 以及 Load Balancer。与 Docker CLI 非常类似的操作命令，对熟悉 Docker 的人非常容易上手学习。</li><li>入门门槛、学习成本较低，使用更便捷，适用于中小型系统。</li></ul></li></ul></li><li>Kubernetes： <ul><li>基本概念： <ul><li>Kubernetes 是基于 Google 在过去十五年来大量生产环境中运行工作负载的经验。Kubernetes 的实现参考了 Google 内部的资源调度框架，但并不是 Borg 的内部容器编排系统的开源，而是借鉴 Google 从运行 Borg 获得的经验教训，形成了 Kubernetes 项目。</li><li>它使用 Label 和 Pod 的概念来将容器划分为逻辑单元。Pods 是同地协作（co-located）容器的集合，这些容器被共同部署和调度，形成了一个服务，这是 Kubernetes 和其他两个框架的主要区别。相比于基于相似度的容器调度方式（就像 Swarm 和Mesos），这个方法简化了对集群的管理。</li></ul></li><li>优势 <ul><li>最流行等容器编排解决方案框架，基于 Google 庞大的生态圈及社区产生的产品。通过 Pods 这一抽象的概念，解决 Container 之间的依赖于通信问题。Pods，Services，Deployments 是独立部署的部分，可以通过 Selector 提供更多的灵活性。内置服务注册表和负载平衡。</li><li>适用度更广，功能更强大，相较于 Mesos 来说节点规模较小，</li></ul></li></ul></li></ul><h2 id="集群架构" tabindex="-1"><a class="header-anchor" href="#集群架构"><span>集群架构</span></a></h2><h3 id="borg" tabindex="-1"><a class="header-anchor" href="#borg"><span>Borg</span></a></h3><p>Borg 是 Google 内部使用了很多年的一个容器化应用管理平台，而 k8s 是根据它的使用经验教训进一步开发出来的，因此可以先了解一下 Borg 的架构，如下：</p><figure><img src="'+n+'" alt="image-20240707175425959" tabindex="0" loading="lazy"><figcaption>image-20240707175425959</figcaption></figure><p>Cell 作为 Borg 系统的核心，而 borgcfg、command-line tools、web browsers 作为外部的调用方式</p><p>Borg 系统系统的核心可以认为是一个主从架构：</p><ul><li>主节点 BorgMaster <ul><li>可以做一些持久化的存储</li><li>用来派发一些任务给从节点</li></ul></li><li>从节点：具体做一些任务</li><li>调度器 scheduler：根据一定的算法去找到相应的从节点执行一些任务</li></ul><h3 id="k8s" tabindex="-1"><a class="header-anchor" href="#k8s"><span>k8s</span></a></h3><figure><img src="'+u+'" alt="architecture" tabindex="0" loading="lazy"><figcaption>architecture</figcaption></figure><p>k8s 类似 Borg，kubectl 调用 Master components</p><ul><li>Master： <ul><li>kubectl 经过认证后，通过 REST 对 Node 进行一系列的操作</li><li><strong>Master 内部的操作全部是通过 REST API 接口完成的，可以把他看做 k8s 的中心</strong></li><li>也可以进行一些分布式的存储工作</li><li>Master 既可以做主节点，又可以做从节点，需要一定的配置</li></ul></li><li>Node： <ul><li>Master 旗下有若干个 Node，每个 Node 包含 kubelet、Proxy、Docker(最新好像不包含) 等组件</li><li>kubelet：负责接口调用的功能</li><li>Node 内部拥有 Pod，去执行一些具体的任务</li></ul></li></ul><h2 id="组件" tabindex="-1"><a class="header-anchor" href="#组件"><span>组件</span></a></h2><blockquote><p>一个kubernetes集群主要是由<strong>控制节点(master)</strong>、**工作节点(node)**构成，每个节点上都会安装不同的组件。</p></blockquote><h3 id="控制面板组件-master" tabindex="-1"><a class="header-anchor" href="#控制面板组件-master"><span>控制面板组件 Master</span></a></h3><p>master：集群的控制平面，负责集群的决策 ( 管理 )</p><ul><li>ApiServer : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制</li><li>Scheduler : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上</li><li>ControllerManager : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等</li><li>Etcd ：负责存储集群中各种资源对象的信息</li></ul><figure><img src="'+d+'" alt="image-20240707193844173" tabindex="0" loading="lazy"><figcaption>image-20240707193844173</figcaption></figure><h3 id="节点组件" tabindex="-1"><a class="header-anchor" href="#节点组件"><span>节点组件</span></a></h3><p>node：集群的数据平面，负责为容器提供运行环境 ( 干活 )</p><ul><li>Kubelet : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器</li><li>KubeProxy : 负责提供集群内部的服务发现和负载均衡</li><li>container-runtime: 负责节点上容器的各种操作</li></ul><figure><img src="'+p+'" alt="image-20240707193900375" tabindex="0" loading="lazy"><figcaption>image-20240707193900375</figcaption></figure><h3 id="其他组件" tabindex="-1"><a class="header-anchor" href="#其他组件"><span>其他组件</span></a></h3><ul><li>kube-dns：负责为整个集群提供 DNS 服务，通过服务名找到对应的 id</li><li>Ingress Controller：为服务提供外网入口，让外部网络访问到内部节点</li><li>Prometheus：提供资源监控</li><li>Dashboard：提供 GUI</li><li>Federation：提供跨可用区的集群，集群间的调度</li><li>Fluentd-elasticsearch：提供集群日志采集、存储与查询</li></ul><h3 id="分层架构" tabindex="-1"><a class="header-anchor" href="#分层架构"><span>分层架构</span></a></h3><figure><img src="'+c+'" alt="kubernetes-layers" tabindex="0" loading="lazy"><figcaption>kubernetes-layers</figcaption></figure><ul><li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴： <ul><li>Kubernetes 外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS 应用、ChatOps 等</li><li>Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等</li></ul></li><li>接口层：kubectl 命令行工具、客户端 SDK 以及集群联邦</li><li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等）</li><li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）</li><li>核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境</li></ul><h2 id="核心概念与专业术语" tabindex="-1"><a class="header-anchor" href="#核心概念与专业术语"><span>核心概念与专业术语</span></a></h2><h3 id="服务的分类" tabindex="-1"><a class="header-anchor" href="#服务的分类"><span>服务的分类</span></a></h3><ul><li>无状态：不会对本地环境产生任何依赖，例如不会存储数据到本地磁盘 <ul><li>代表应用 <ul><li>Nginx</li><li>Apache</li></ul></li><li>优点：对客户端透明，无依赖关系，可以高效实现扩容、迁移</li><li>缺点：不能存储数据，需要额外的数据服务支撑</li></ul></li><li>有状态：会对本地环境产生依赖 <ul><li>代表应用 <ul><li>MySQL</li><li>Redis</li></ul></li><li>优点：可以独立存储数据，实现数据管理</li><li>缺点：集群环境下需要实现主从、数据同步、备份、水平扩容复杂</li></ul></li></ul><h3 id="资源和对象" tabindex="-1"><a class="header-anchor" href="#资源和对象"><span>资源和对象</span></a></h3><blockquote><p>Kubernetes 中的所有内容都被抽象为“资源”，如 Pod、Service、Node 等都是资源。“对象”就是“资源”的实例，是持久化的实体。如某个具体的 Pod、某个具体的 Node。Kubernetes 使用这些实体去表示整个集群的状态。</p><p>对象的创建、删除、修改都是通过 “Kubernetes API”，也就是 “Api Server” 组件提供的 API 接口，这些是 RESTful 风格的 Api，与 k8s 的“万物皆对象”理念相符。命令行工具 “kubectl”，实际上也是调用 kubernetes api。</p><p>K8s 中的资源类别有很多种，kubectl 可以通过配置文件来创建这些 “对象”，配置文件更像是描述对象“属性”的文件，配置文件格式可以是 “JSON” 或 “YAML”，常用 “YAML”。</p></blockquote>',44)),t(i,{id:"mermaid-572",code:"eJxLL0osyFAIceFSAALH6BdbW57tmhAL4Sno6topOEU/bW1+NnXDs951yMLO0S9ntz3ft+T5ruXIwi7RTyfufTqh9/nKXS+nb4FKcgEAfYEonA=="}),e[1]||(e[1]=l('<figure><img src="'+h+'" alt="image-20240728204453536" tabindex="0" loading="lazy"><figcaption>image-20240728204453536</figcaption></figure><h4 id="元数据型" tabindex="-1"><a class="header-anchor" href="#元数据型"><span>元数据型</span></a></h4><p><em>对于资源的元数据描述， 每一个资源都可以使用元空间的数据</em></p><ul><li>Horizontal Pod Autoscaler（HPA）：Pod 自动扩容：可以根据 CPU 使用率或自定义指标（metrics）自动对 Pod 进行扩/缩容。 <ul><li>控制管理器每隔30s（可以通过–horizontal-pod-autoscaler-sync-period修改）查询metrics的资源使用情况</li><li>支持三种metrics类型 <ul><li>预定义metrics（比如Pod的CPU）以利用率的方式计算</li><li>自定义的Pod metrics，以原始值（raw value）的方式计算</li><li>自定义的object metrics</li></ul></li><li>支持两种metrics查询方式：Heapster和自定义的REST API</li><li>支持多metrics</li></ul></li><li>PodTemplate <ul><li>Pod Template 是关于 Pod 的定义，但是被包含在其他的 Kubernetes 对象中（例如 Deployment、StatefulSet、DaemonSet 等控制器）。控制器通过 Pod Template 信息来创建 Pod。</li></ul></li><li>LimitRange <ul><li>可以对集群内 Request 和 Limits 的配置做一个全局的统一的限制，相当于批量设置了某一个范围内（某个命名空间）的 Pod 的资源使用限制。</li></ul></li></ul><h4 id="集群级" tabindex="-1"><a class="header-anchor" href="#集群级"><span>集群级</span></a></h4><ul><li>Namespace <ul><li>Kubernetes 支持多个虚拟集群，它们底层依赖于同一个物理集群，这些虚拟集群被称为命名空间。</li><li>作用是用于实现多团队/环境的资源隔离。</li><li>命名空间 namespace 是 k8s 集群级别的资源，可以给不同的用户、租户、环境或项目创建对应的命名空间。</li><li>默认 namespace： <ul><li>kube-system 主要用于运行系统级资源，存放 k8s 自身的组件</li><li>kube-public 此命名空间是自动创建的，并且可供所有用户（包括未经过身份验证的用户）读取。此命名空间主要用于集群使用，关联的一些资源在集群中是可见的并且可以公开读取。此命名空间的公共方面知识一个约定，但不是非要这么要求。</li><li>default 未指定名称空间的资源就是 default，即你在创建pod 时如果没有指定 namespace，则会默认使用 default</li></ul></li></ul></li><li>Node <ul><li>不像其他的资源（如 Pod 和 Namespace），Node 本质上不是Kubernetes 来创建的，Kubernetes 只是管理 Node 上的资源。虽然可以通过 Manifest 创建一个Node对象（如下 json 所示），但 Kubernetes 也只是去检查是否真的是有这么一个 Node，如果检查失败，也不会往上调度 Pod。</li></ul></li><li>ClusterRole <ul><li>ClusterRole 是一组权限的集合，但与 Role 不同的是，ClusterRole 可以在包括所有 Namespace 和集群级别的资源或非资源类型进行鉴权。</li></ul></li><li>ClusterRoleBinding <ul><li>ClusterRoleBinding：将 Subject 绑定到 ClusterRole，ClusterRoleBinding 将使规则在所有命名空间中生效。</li></ul></li></ul><h4 id="命名空间-★★★" tabindex="-1"><a class="header-anchor" href="#命名空间-★★★"><span>命名空间 ★★★</span></a></h4><h5 id="工作负载型-pod" tabindex="-1"><a class="header-anchor" href="#工作负载型-pod"><span>工作负载型(Pod)</span></a></h5><blockquote><p>Pod（容器组）是 Kubernetes 中最小的可部署单元。一个 Pod（容器组）包含了一个应用程序容器（某些情况下是多个容器）、存储资源、一个唯一的网络 IP 地址、以及一些确定容器该如何运行的选项。Pod 容器组代表了 Kubernetes 中一个独立的应用程序运行实例，该实例可能由单个容器或者几个紧耦合在一起的容器组成。</p><p>Docker 是 Kubernetes Pod 中使用最广泛的容器引擎；Kubernetes Pod 同时也支持其他类型的容器引擎。<br> Kubernetes 集群中的 Pod 存在如下两种使用途径：</p><ul><li>一个 Pod 中只运行一个容器。&quot;one-container-per-pod&quot; 是 Kubernetes 中最常见的使用方式。此时，您可以认为 Pod 容器组是该容器的 wrapper，Kubernetes 通过 Pod 管理容器，而不是直接管理容器。</li><li>一个 Pod 中运行多个需要互相协作的容器。您可以将多个紧密耦合、共享资源且始终在一起运行的容器编排在同一个 Pod 中，可能的情况有：</li></ul></blockquote><h6 id="副本-replicas" tabindex="-1"><a class="header-anchor" href="#副本-replicas"><span>副本（replicas）</span></a></h6><p>先引入“副本”的概念——一个 Pod 可以被复制成多份，每一份可被称之为一个“副本”，这些“副本”除了一些描述性的信息（Pod 的名字、uid 等）不一样以外，其它信息都是一样的，譬如 Pod 内部的容器、容器数量、容器里面运行的应用等的这些信息都是一样的，这些副本提供同样的功能。</p><p>Pod 的<strong>控制器</strong>通常包含一个名为 “replicas” 的属性。“replicas”属性则指定了特定 Pod 的副本的数量，当当前集群中该 Pod 的数量与该属性指定的值不一致时，k8s 会采取一些策略去使得当前状态满足配置的要求。</p><h6 id="控制器" tabindex="-1"><a class="header-anchor" href="#控制器"><span>控制器</span></a></h6><blockquote><p>当 Pod 被创建出来，Pod 会被调度到集群中的节点上运行，Pod 会在该节点上一直保持运行状态，直到进程终止、Pod 对象被删除、Pod 因节点资源不足而被驱逐或者节点失效为止。Pod 并不会自愈，当节点失效，或者调度 Pod 的这一操作失败了，Pod 就该被删除。如此，单单用 Pod 来部署应用，是不稳定不安全的。</p><p>Kubernetes 使用更高级的资源对象 <strong>“控制器”</strong> 来实现对Pod的管理。控制器可以为您创建和管理多个 Pod，管理副本和上线，并在集群范围内提供自修复能力。 例如，如果一个节点失败，控制器可以在不同的节点上调度一样的替身来自动替换 Pod。</p></blockquote><p>1、适用无状态服务</p><ul><li><p>ReplicationController（RC）<br> Replication Controller 简称 RC，RC 是 Kubernetes 系统中的核心概念之一，简单来说，RC 可以保证在任意时间运行 Pod 的副本数量，能够保证 Pod 总是可用的。如果实际 Pod 数量比指定的多那就结束掉多余的，如果实际数量比指定的少就新启动一些Pod，当 Pod 失败、被删除或者挂掉后，RC 都会去自动创建新的 Pod 来保证副本数量，所以即使只有一个 Pod，我们也应该使用 RC 来管理我们的 Pod。可以说，通过 ReplicationController，Kubernetes 实现了 Pod 的高可用性。<em>已于v1.11 版本废弃。</em></p></li><li><p>ReplicaSet（RS）</p><ul><li><p>Label 和 Selector</p><p>​ label （标签）是附加到 Kubernetes 对象（比如 Pods）上的键值对，用于区分对象（比如Pod、Service）。 label 旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。 label 可以用于组织和选择对象的子集。label 可以在创建时附加到对象，随后可以随时添加和修改。可以像 namespace 一样，使用 label 来获取某类对象，但 label 可以与 selector 一起配合使用，用表达式对条件加以限制，实现更精确、更灵活的资源查找。</p><p>​ label 与 selector 配合，可以实现对象的“关联”，“Pod 控制器” 与 Pod 是相关联的 —— “Pod 控制器”依赖于 Pod，可以给 Pod 设置 label，然后给“控制器”设置对应的 selector，这就实现了对象的关联。</p></li></ul></li><li><p>Deployment</p><p>​ <em>实际情况，我们既不用 RC 也不用 RS，而是用 Deployment</em><br> ​ Deployment 为 Pod 和 Replica Set 提供声明式更新。</p><p>​ 你只需要在 Deployment 中描述你想要的目标状态是什么，Deployment controller 就会帮你将 Pod 和 Replica Set 的实际状态改变到你的目标状态。你可以定义一个全新的 Deployment，也可以创建一个新的替换旧的 Deployment。</p><ul><li>创建 Replica Set / Pod</li><li>滚动升级/回滚</li><li>平滑扩容和缩容</li><li>暂停与恢复 Deployment</li></ul></li></ul><p>2、适用有状态服务</p><ul><li>StatefulSet<br> StatefulSet 中每个 Pod 的 DNS 格式为 statefulSetName-{0..N-1}.serviceName.namespace.svc.cluster.local <ul><li>主要特点 <ul><li>稳定的持久化存储：即 Pod 重新调度后还是能访问到相同的持久化数据，基于 PVC 来实现</li><li>稳定的网络标志：稳定的网络标志，即 Pod 重新调度后其 PodName 和 HostName 不变，基于 Headless Service（即没有 Cluster IP 的 Service）来实现</li><li>有序部署，有序扩展：有序部署，有序扩展，即 Pod 是有顺序的，在部署或者扩展的时候要依据定义的顺序依次进行</li><li>有序收缩，有序删除：有序收缩，有序删除（即从 N-1 到 0）</li></ul></li><li>组成 <ul><li>Headless Service：用于定义网络标志（DNS domain）</li><li>volumeClaimTemplate：用于创建 PersistentVolumes</li></ul></li><li>注意事项 <ul><li>kubernetes v1.5 版本以上才支持</li><li>所有Pod的Volume必须使用PersistentVolume或者是管理员事先创建好</li><li>为了保证数据安全，删除StatefulSet时不会删除Volume</li><li>StatefulSet 需要一个 Headless Service 来定义 DNS domain，需要在 StatefulSet 之前创建好</li></ul></li></ul></li></ul><p>3、守护进程</p><ul><li>DaemonSet：保证在每个 Node 上都运行一个容器副本，常用来部署一些集群的日志、监控或者其他系统管理应用。可以通过 nodeSelector 帮助我们快速将守护进程部署到指定节点</li></ul><p>4、任务/定时任务</p><ul><li>Job：一次性任务，运行完成后Pod销毁，不再重新启动新容器。</li><li>CronJob：CronJob 是在 Job 基础上加上了定时功能。</li></ul><h5 id="服务发现" tabindex="-1"><a class="header-anchor" href="#服务发现"><span>服务发现</span></a></h5><figure><img src="'+m+'" alt="image-20240731224612631" tabindex="0" loading="lazy"><figcaption>image-20240731224612631</figcaption></figure><ul><li>Service</li><li>Ingress</li></ul><h5 id="存储" tabindex="-1"><a class="header-anchor" href="#存储"><span>存储</span></a></h5><ul><li>Volume</li><li>CSI</li></ul><h5 id="特殊类型配置" tabindex="-1"><a class="header-anchor" href="#特殊类型配置"><span>特殊类型配置</span></a></h5><ul><li>ConfigMap</li><li>Secret</li><li>DownwardAPI</li></ul><h5 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h5><ul><li>Role</li><li>RoleBinding</li></ul><h3 id="对象规约和状态" tabindex="-1"><a class="header-anchor" href="#对象规约和状态"><span>对象规约和状态</span></a></h3><blockquote><p>对象是用来完成一些任务的，是持久的，是有目的性的，因此 kubernetes 创建一个对象后，将持续地工作以确保对象存在。当然，kubernetes 并不只是维持对象的存在这么简单，kubernetes 还管理着对象的方方面面。每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置，他们分别是 “spec” 和 “status” 。</p></blockquote><h4 id="规约-spec" tabindex="-1"><a class="header-anchor" href="#规约-spec"><span>规约（Spec）</span></a></h4><p>“spec” 是 “规约”、“规格” 的意思，spec 是必需的，它描述了对象的期望状态（Desired State）—— 希望对象所具有的特征。当创建 Kubernetes 对象时，必须提供对象的规约，用来描述该对象的期望状态，以及关于对象的一些基本信息（例如名称）。</p><h4 id="状态-status" tabindex="-1"><a class="header-anchor" href="#状态-status"><span>状态（Status）</span></a></h4><p>表示对象的实际状态，该属性由 k8s 自己维护，k8s 会通过一系列的控制器对对应对象进行管理，让对象尽可能的让实际状态与期望状态重合。</p>',37))])}const S=a(b,[["render",g],["__file","01-k8s核心概念.html.vue"]]),K=JSON.parse('{"path":"/knowledge/Java/JavaEE/k8s/01-k8s%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html","title":"k8s核心概念","lang":"zh-CN","frontmatter":{"description":"k8s核心概念 认识k8s 什么是k8s Kubernetes 是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful），Kubernetes 提供了应用部署，规划，更新，维护的一种机制。是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器Borg系...","head":[["meta",{"property":"og:url","content":"https://jishuzhaix.cn/knowledge/Java/JavaEE/k8s/01-k8s%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html"}],["meta",{"property":"og:site_name","content":"技数斋"}],["meta",{"property":"og:title","content":"k8s核心概念"}],["meta",{"property":"og:description","content":"k8s核心概念 认识k8s 什么是k8s Kubernetes 是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful），Kubernetes 提供了应用部署，规划，更新，维护的一种机制。是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器Borg系..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-22T12:24:50.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-22T12:24:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"k8s核心概念\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-22T12:24:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"贺墨于\\",\\"url\\":\\"https://jishuzhaix.cn\\"}]}"]]},"headers":[{"level":2,"title":"认识k8s","slug":"认识k8s","link":"#认识k8s","children":[{"level":3,"title":"什么是k8s","slug":"什么是k8s","link":"#什么是k8s","children":[]},{"level":3,"title":"为什么需要k8s","slug":"为什么需要k8s","link":"#为什么需要k8s","children":[]},{"level":3,"title":"企业级容器调度平台","slug":"企业级容器调度平台","link":"#企业级容器调度平台","children":[]}]},{"level":2,"title":"集群架构","slug":"集群架构","link":"#集群架构","children":[{"level":3,"title":"Borg","slug":"borg","link":"#borg","children":[]},{"level":3,"title":"k8s","slug":"k8s","link":"#k8s","children":[]}]},{"level":2,"title":"组件","slug":"组件","link":"#组件","children":[{"level":3,"title":"控制面板组件 Master","slug":"控制面板组件-master","link":"#控制面板组件-master","children":[]},{"level":3,"title":"节点组件","slug":"节点组件","link":"#节点组件","children":[]},{"level":3,"title":"其他组件","slug":"其他组件","link":"#其他组件","children":[]},{"level":3,"title":"分层架构","slug":"分层架构","link":"#分层架构","children":[]}]},{"level":2,"title":"核心概念与专业术语","slug":"核心概念与专业术语","link":"#核心概念与专业术语","children":[{"level":3,"title":"服务的分类","slug":"服务的分类","link":"#服务的分类","children":[]},{"level":3,"title":"资源和对象","slug":"资源和对象","link":"#资源和对象","children":[]},{"level":3,"title":"对象规约和状态","slug":"对象规约和状态","link":"#对象规约和状态","children":[]}]}],"git":{"createdTime":1739802080000,"updatedTime":1740227090000,"contributors":[{"name":"HeMOu","username":"HeMOu","email":"fangqichenchao@163.com","commits":2,"url":"https://github.com/HeMOu"}]},"readingTime":{"minutes":17.93,"words":5378},"filePathRelative":"knowledge/Java/JavaEE/k8s/01-k8s核心概念.md","localizedDate":"2025年2月17日","excerpt":"\\n<h2>认识k8s</h2>\\n<h3>什么是k8s</h3>\\n<p><strong>Kubernetes</strong> 是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful），Kubernetes 提供了应用部署，规划，更新，维护的一种机制。是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。</p>\\n<p>kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：</p>","autoDesc":true}');export{S as comp,K as data};
