import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as e,o}from"./app-Gj0sH8Bx.js";const r={};function n(a,l){return o(),t("div",null,l[0]||(l[0]=[e('<h1 id="排错日志" tabindex="-1"><a class="header-anchor" href="#排错日志"><span>排错日志</span></a></h1><p>2022年4月6日10点42分</p><ul><li>经过一系列修复，类别损失和边界框损失看上过去想那么回事了，但是置信度损失下降的非常慢，而源代码每 10 个 iter 就会下降很多</li><li>目前推测是置信度的 ground truth 写错了，也就是 iou计算有问题 <ul><li>发现之前计算iou时，pred的边界框位置索引写错了，但是训练置信度损失下降的还是很慢，并经过1个epoch训练后detect效果贼差劲</li><li>发现是 detect 函数的尺寸归一错了，应该是除以 grid_num，而不是 image 的 input_size</li><li>检测虽然好看了那么一点，但是 lobj 下降的还是很慢，同时换一张图片检测的还是很离谱</li></ul></li><li>应该就是置信度有问题 <ul><li>置信度相关变量 <ul><li>预测置信度：pred[..., 0]</li><li>真实置信度，也就是iou值：targets[..., 7] <ul><li>真实边界框 xywh -&gt; xywh = xywh * gn 还原特征图尺度 -&gt; xy - xy.floor() 获取中心坐标，[xy - xy.floor(), wh] 代表在 特征图尺寸的边界框大小</li><li>预测边界框 pbox = pred[..., 1:5] -&gt; pbox[..., :2].sigmoid pbox[..., :2].exp * anchor_wh</li><li>。。。</li><li>仔细想了一下，还是没找到bug</li></ul></li><li>掩码：targets[..., 0]</li></ul></li></ul></li></ul><p>2022年4月7日08点39分</p><p>training 1/102, iter 722/722, lr 0.000994: : 722it [08:00, 1.50it/s, lcls=1.28, lbox=4.24, lobj=148, liou=1.45, mem_occupy=10.7G, total=154]<br> training 2/102, iter 722/722, lr 0.001000: : 722it [07:42, 1.56it/s, lcls=6.81, lbox=5.81, lobj=27.5, liou=4.1, mem_occupy=10.7G, total=40.1]<br> training 3/102, iter 722/722, lr 0.001000: : 722it [07:50, 1.54it/s, lcls=1.76, lbox=4.18, lobj=8.1, liou=3.73, mem_occupy=10.7G, total=14]<br> training 4/102, iter 722/722, lr 0.001000: : 722it [07:44, 1.55it/s, lcls=4.07, lbox=7.81, lobj=7.46, liou=5.72, mem_occupy=10.7G, total=19.3]<br> training 5/102, iter 722/722, lr 0.001000: : 722it [07:52, 1.53it/s, lcls=3.46, lbox=12.8, lobj=12.7, liou=11.8, mem_occupy=10.7G, total=28.9]<br> 。。。。<br> training 68/102, iter 722/722, lr 0.001000: : 722it [07:46, 1.55it/s, lcls=0.726, lbox=6.07, lobj=3.18, liou=12.3, mem_occupy=10.7G, total=9.98]<br> training 69/102, iter 722/722, lr 0.001000: : 722it [07:47, 1.54it/s, lcls=0.893, lbox=5.58, lobj=4.63, liou=8.88, mem_occupy=10.7G, total=11.1]<br> training 70/102, iter 722/722, lr 0.001000: : 722it [07:57, 1.51it/s, lcls=0.0681, lbox=2.03, lobj=2.28, liou=1.9, mem_occupy=10.7G, total=4.38]<br> training 71/102, iter 722/722, lr 0.001000: : 722it [07:35, 1.59it/s, lcls=0.471, lbox=4.19, lobj=3.37, liou=10.6, mem_occupy=10.7G, total=8.03]<br> training 72/102, iter 722/722, lr 0.001000: : 722it [07:34, 1.59it/s, lcls=0.517, lbox=5.3, lobj=3.01, liou=12.7, mem_occupy=10.7G, total=8.83]<br> training 73/102, iter 450/722, lr 0.001000: : 450it [04:47, 1.17it/s, lcls=0.147, lbox=5.42, lobj=3.74, liou=8.53, mem_occupy=10.7G, total=9.31]</p><p>就离谱，训练了9个小时，loss 根本没有显著的变化，八成是损失函数的问题</p><ul><li>暂时排除置信度和类别损失的问题，下面看边界框损失</li><li>边界框损失需要 <ul><li>预测边界框 pred[..., 1:5]</li><li>真实边界框 targets[..., 2:6]</li><li></li></ul></li></ul>',7)]))}const p=i(r,[["render",n],["__file","排错日志.html.vue"]]),s=JSON.parse('{"path":"/knowledge/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/YOLOv2/%E6%8E%92%E9%94%99%E6%97%A5%E5%BF%97.html","title":"排错日志","lang":"zh-CN","frontmatter":{"description":"排错日志 2022年4月6日10点42分 经过一系列修复，类别损失和边界框损失看上过去想那么回事了，但是置信度损失下降的非常慢，而源代码每 10 个 iter 就会下降很多 目前推测是置信度的 ground truth 写错了，也就是 iou计算有问题 发现之前计算iou时，pred的边界框位置索引写错了，但是训练置信度损失下降的还是很慢，并经过1个e...","head":[["meta",{"property":"og:url","content":"https://jishuzhaix.cn/knowledge/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/YOLOv2/%E6%8E%92%E9%94%99%E6%97%A5%E5%BF%97.html"}],["meta",{"property":"og:site_name","content":"技数斋"}],["meta",{"property":"og:title","content":"排错日志"}],["meta",{"property":"og:description","content":"排错日志 2022年4月6日10点42分 经过一系列修复，类别损失和边界框损失看上过去想那么回事了，但是置信度损失下降的非常慢，而源代码每 10 个 iter 就会下降很多 目前推测是置信度的 ground truth 写错了，也就是 iou计算有问题 发现之前计算iou时，pred的边界框位置索引写错了，但是训练置信度损失下降的还是很慢，并经过1个e..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-17T14:21:20.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-17T14:21:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"排错日志\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-17T14:21:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"贺墨于\\",\\"url\\":\\"https://jishuzhaix.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1739802080000,"updatedTime":1739802080000,"contributors":[{"name":"HeMOu","username":"HeMOu","email":"fangqichenchao@163.com","commits":1,"url":"https://github.com/HeMOu"}]},"readingTime":{"minutes":2.16,"words":648},"filePathRelative":"knowledge/人工智能/算法详解/目标检测/YOLOv2/排错日志.md","localizedDate":"2025年2月17日","excerpt":"\\n<p>2022年4月6日10点42分</p>\\n<ul>\\n<li>经过一系列修复，类别损失和边界框损失看上过去想那么回事了，但是置信度损失下降的非常慢，而源代码每 10 个 iter 就会下降很多</li>\\n<li>目前推测是置信度的 ground truth 写错了，也就是 iou计算有问题\\n<ul>\\n<li>发现之前计算iou时，pred的边界框位置索引写错了，但是训练置信度损失下降的还是很慢，并经过1个epoch训练后detect效果贼差劲</li>\\n<li>发现是 detect 函数的尺寸归一错了，应该是除以 grid_num，而不是 image 的 input_size</li>\\n<li>检测虽然好看了那么一点，但是 lobj 下降的还是很慢，同时换一张图片检测的还是很离谱</li>\\n</ul>\\n</li>\\n<li>应该就是置信度有问题\\n<ul>\\n<li>置信度相关变量\\n<ul>\\n<li>预测置信度：pred[..., 0]</li>\\n<li>真实置信度，也就是iou值：targets[..., 7]\\n<ul>\\n<li>真实边界框 xywh -&gt; xywh = xywh * gn 还原特征图尺度 -&gt;  xy - xy.floor() 获取中心坐标，[xy - xy.floor(), wh] 代表在 特征图尺寸的边界框大小</li>\\n<li>预测边界框 pbox = pred[..., 1:5] -&gt; pbox[..., :2].sigmoid   pbox[..., :2].exp * anchor_wh</li>\\n<li>。。。</li>\\n<li>仔细想了一下，还是没找到bug</li>\\n</ul>\\n</li>\\n<li>掩码：targets[..., 0]</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{p as comp,s as data};
