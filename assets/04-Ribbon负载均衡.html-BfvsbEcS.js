import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as s,o as n}from"./app-DOkRBtKU.js";const t="/assets/image-20220114165819338-CiqinXH3.png",l="/assets/image-20220114170246431-TQvipoC_.png",r="/assets/image-20220114170400450-gJxALGz5.png",p="/assets/image-20220114193110364-fwQQN_WQ.png",o="/assets/image-20220114193416568-BlNhRPku.png",d="/assets/image-20220114193832502-CTYFYJDM.png",g="/assets/image-20220114194426935-BMWe3SfN.png",h="/assets/image-20220114194629256-DEwyAOJF.png",c="/assets/image-20220114194846757-kTBKSNvu.png",k="/assets/image-20220114195237274-GGYvisc6.png",m="/assets/image-20220114195414986-DyaBE1IX.png",u="/assets/image-20220114195625189-CIsHNogB.png",b="/assets/image-20220115105831176-Dra_WI5G.png",f={};function y(v,i){return n(),a("div",null,i[0]||(i[0]=[s('<h1 id="ribbon负载均衡" tabindex="-1"><a class="header-anchor" href="#ribbon负载均衡"><span>Ribbon负载均衡</span></a></h1><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><figure><img src="'+t+'" alt="image-20220114165819338" tabindex="0" loading="lazy"><figcaption>image-20220114165819338</figcaption></figure><p>首先以服务名作为url地址在浏览器中肯定是访问不了的，所以这里面必定有一个拦截器将请求给拦截下来，下面查看源码</p><h3 id="代码详解" tabindex="-1"><a class="header-anchor" href="#代码详解"><span>代码详解</span></a></h3><p>先找到<code>LoadBalancerInterceptor</code>类，发现他继承<code>ClientHttpRequestInterceptor</code></p><figure><img src="'+l+'" alt="image-20220114170246431" tabindex="0" loading="lazy"><figcaption>image-20220114170246431</figcaption></figure><p>能发现<code>ClientHttpRequestInterceptor</code>就是进行HTTP拦截的</p><figure><img src="'+r+'" alt="image-20220114170400450" tabindex="0" loading="lazy"><figcaption>image-20220114170400450</figcaption></figure><p>它拥有一个接口方法<code>intercept</code>如下所示</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ClientHttpResponse</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> intercept</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">HttpRequest</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> request</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] body</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ClientHttpRequestExecution</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> execution) throws IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>LoadBalancerInterceptor</code>类实现了它，因此在这里打上断点方便查看</p><figure><img src="'+p+'" alt="image-20220114193110364" tabindex="0" loading="lazy"><figcaption>image-20220114193110364</figcaption></figure><p>如图上图红框框住所示，在此方法中获取了服务名</p><figure><img src="'+o+'" alt="image-20220114193416568" tabindex="0" loading="lazy"><figcaption>image-20220114193416568</figcaption></figure><figure><img src="'+d+'" alt="image-20220114193832502" tabindex="0" loading="lazy"><figcaption>image-20220114193832502</figcaption></figure><p>然后接着深入，发现内部能通过<code>getLoadBalancer</code>方法根据这个服务名<strong>拉取</strong>相对应的所有主机列表</p><p><code>getLoadBalancer</code>方法执行完毕后，接着深入查看<code>getServer</code>方法做了什么</p><figure><img src="'+g+'" alt="image-20220114194426935" tabindex="0" loading="lazy"><figcaption>image-20220114194426935</figcaption></figure><p>深入后发现，有一个<code>rule</code>对象</p><figure><img src="'+h+'" alt="image-20220114194629256" tabindex="0" loading="lazy"><figcaption>image-20220114194629256</figcaption></figure><p>接着查看<code>rule</code>对象所属哪个类，能发现它是一个接口对象，有数个实现类，包括我们知道的轮询规则和随机规则</p><figure><img src="'+c+'" alt="image-20220114194846757" tabindex="0" loading="lazy"><figcaption>image-20220114194846757</figcaption></figure><p>因此<code>getServer</code>的作用就是<strong>负责均衡</strong>，根据一定的规则选择相应的主机</p><h3 id="图解流程" tabindex="-1"><a class="header-anchor" href="#图解流程"><span>图解流程</span></a></h3><figure><img src="'+k+'" alt="image-20220114195237274" tabindex="0" loading="lazy"><figcaption>image-20220114195237274</figcaption></figure><h2 id="负载均衡策略" tabindex="-1"><a class="header-anchor" href="#负载均衡策略"><span>负载均衡策略</span></a></h2><p>Ribbon的负载均衡规则是一个叫做lRule的接口来定义的，每一个子接口都是一种规则：</p><figure><img src="'+m+'" alt="image-20220114195414986" tabindex="0" loading="lazy"><figcaption>image-20220114195414986</figcaption></figure><figure><img src="'+u+`" alt="image-20220114195625189" tabindex="0" loading="lazy"><figcaption>image-20220114195625189</figcaption></figure><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><p>1）代码方式：在order-service中的OrderApplication类中，定义一个新的IRule:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> IRule</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> rule</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> RandomRule</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方法是作用于全局的，即在此模块内调用所有的微服务接口都使用这种规则</p><p>2）配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则</p><div class="language-yml line-numbers-mode" data-highlighter="shiki" data-ext="yml" data-title="yml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">userservice</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  ribbon</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    NFLoadBalancerRuleClassName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">com.netflix.loadbalancer.RandomRule</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方法是作用于指定服务的</p><h2 id="加载策略" tabindex="-1"><a class="header-anchor" href="#加载策略"><span>加载策略</span></a></h2><p>由上<code>代码详解</code>可知负载均衡是通过HTTP过滤器中的<code>loadBalancer</code>实现的，而加载策略就是进行<code>loadBalancer</code>如何初始化的考虑</p><figure><img src="`+b+`" alt="image-20220115105831176" tabindex="0" loading="lazy"><figcaption>image-20220115105831176</figcaption></figure><p>Ribbon默认是采用<strong>懒加载</strong>，即第一次访问时才会去创建<code>LoadBalanceClient</code>，请求时间会很长。而<strong>饥饿加载</strong>则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><div class="language-yml line-numbers-mode" data-highlighter="shiki" data-ext="yml" data-title="yml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ribbon</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  eager-load</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    enabled</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    clients</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">userserver</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ol><li>Ribbon负载均衡规则</li></ol><ul><li>规则接口是IRule</li><li>默认实现是ZoneAvoidanceRule，根据zone选择服务列表，然后轮询</li></ul><ol start="2"><li>负载均衡自定义方式 <ul><li>代码方式：配置灵活，但修改时需要重新打包发布</li><li>配置方式：直观，方便，无需重新打包发布，但是无法做全局配置</li></ul></li><li>饥饿加载 <ul><li>开启饥饿加载</li><li>指定饥饿加载的微服务名称</li></ul></li></ol>`,46)]))}const C=e(f,[["render",y],["__file","04-Ribbon负载均衡.html.vue"]]),E=JSON.parse('{"path":"/knowledge/Java/JavaEE/SpringCloud/04-Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html","title":"Ribbon负载均衡","lang":"zh-CN","frontmatter":{"description":"Ribbon负载均衡 原理 image-20220114165819338image-20220114165819338 首先以服务名作为url地址在浏览器中肯定是访问不了的，所以这里面必定有一个拦截器将请求给拦截下来，下面查看源码 代码详解 先找到LoadBalancerInterceptor类，发现他继承ClientHttpRequestInter...","head":[["meta",{"property":"og:url","content":"https://jishuzhaix.cn/knowledge/Java/JavaEE/SpringCloud/04-Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"}],["meta",{"property":"og:site_name","content":"技数斋"}],["meta",{"property":"og:title","content":"Ribbon负载均衡"}],["meta",{"property":"og:description","content":"Ribbon负载均衡 原理 image-20220114165819338image-20220114165819338 首先以服务名作为url地址在浏览器中肯定是访问不了的，所以这里面必定有一个拦截器将请求给拦截下来，下面查看源码 代码详解 先找到LoadBalancerInterceptor类，发现他继承ClientHttpRequestInter..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-17T14:21:20.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-17T14:21:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Ribbon负载均衡\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-17T14:21:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"贺墨于\\",\\"url\\":\\"https://jishuzhaix.cn\\"}]}"]]},"headers":[{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[{"level":3,"title":"代码详解","slug":"代码详解","link":"#代码详解","children":[]},{"level":3,"title":"图解流程","slug":"图解流程","link":"#图解流程","children":[]}]},{"level":2,"title":"负载均衡策略","slug":"负载均衡策略","link":"#负载均衡策略","children":[]},{"level":2,"title":"加载策略","slug":"加载策略","link":"#加载策略","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1739802080000,"updatedTime":1739802080000,"contributors":[{"name":"HeMOu","username":"HeMOu","email":"fangqichenchao@163.com","commits":1,"url":"https://github.com/HeMOu"}]},"readingTime":{"minutes":2.49,"words":747},"filePathRelative":"knowledge/Java/JavaEE/SpringCloud/04-Ribbon负载均衡.md","localizedDate":"2025年2月17日","excerpt":"\\n<h2>原理</h2>\\n<figure><figcaption>image-20220114165819338</figcaption></figure>\\n<p>首先以服务名作为url地址在浏览器中肯定是访问不了的，所以这里面必定有一个拦截器将请求给拦截下来，下面查看源码</p>\\n<h3>代码详解</h3>\\n<p>先找到<code>LoadBalancerInterceptor</code>类，发现他继承<code>ClientHttpRequestInterceptor</code></p>\\n<figure><figcaption>image-20220114170246431</figcaption></figure>","autoDesc":true}');export{C as comp,E as data};
