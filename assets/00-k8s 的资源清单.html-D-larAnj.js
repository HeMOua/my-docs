import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,o as r}from"./app-BDhRxcGH.js";const s={};function o(a,t){return r(),n("div",null,t[0]||(t[0]=[e('<h1 id="k8s-的资源清单" tabindex="-1"><a class="header-anchor" href="#k8s-的资源清单"><span>K8S 的资源清单</span></a></h1><table><thead><tr><th>参数名</th><th>类型</th><th>字段说明</th></tr></thead><tbody><tr><td>apiVersion</td><td>String</td><td>K8S APl 的版本，可以用 kubectl api versions 命令查询</td></tr><tr><td>kind</td><td>String</td><td>yam 文件定义的资源类型和角色</td></tr><tr><td>metadata</td><td>Object</td><td>元数据对象，下面是它的属性</td></tr><tr><td><a href="http://metadata.name" target="_blank" rel="noopener noreferrer">metadata.name</a></td><td>String</td><td>元数据对象的名字，比如 pod 的名字</td></tr><tr><td>metadata.namespace</td><td>String</td><td>元数据对象的命名空间</td></tr><tr><td>Spec</td><td>Object</td><td>详细定义对象</td></tr><tr><td>spec.containers[]</td><td>list</td><td>定义 Spec 对象的容器列表</td></tr><tr><td>spec.containers[].name</td><td>String</td><td>为列表中的某个容器定义名称</td></tr><tr><td>spec.containers[].image</td><td>String</td><td>为列表中的某个容器定义需要的镜像名称</td></tr><tr><td>spec.containers[].imagePullPolicy</td><td>string</td><td>定义镜像拉取策略，有 Always、Never、IfNotPresent 三个值可选<br> - Always（默认）：意思是每次都尝试重新拉取镜像<br> - Never：表示仅适用本地镜像<br> - IfNotPresent：如果本地有镜像就使用本地镜像，没有就拉取在线镜像。</td></tr><tr><td>spec.containers[].command[]</td><td>list</td><td>指定容器启动命令，因为是数组可以指定多个，不指定则使用镜像打包时使用的启动命令。</td></tr><tr><td>spec.containers[].args[]</td><td>list</td><td>指定容器启动命令参数，因为是数组可以指定多个。</td></tr><tr><td>spec.containers[].workingDir</td><td>string</td><td>指定容器的工作目录</td></tr><tr><td>spec.containers[].volumeMounts[]</td><td>list</td><td>指定容器内部的存储卷配置</td></tr><tr><td>spec.containers[].volumeMounts[].name</td><td>string</td><td>指定可以被容器挂载的存储卷的名称</td></tr><tr><td>spec.containers[].volumeMounts[].mountPath</td><td>string</td><td>指定可以被容器挂载的存储卷的路径</td></tr><tr><td>spec.containers[].volumeMounts[].readOnly</td><td>string</td><td>设置存储卷路径的读写模式，ture 或者 false，默认是读写模式</td></tr><tr><td>spec.containers[].ports[]</td><td>list</td><td>指定容器需要用到的端口列表</td></tr><tr><td>spec.containers[].ports[].name</td><td>string</td><td>指定端口的名称</td></tr><tr><td>spec.containers[].ports[].containerPort</td><td>string</td><td>指定容器需要监听的端口号</td></tr><tr><td>spec.containers[].ports[].hostPort</td><td>string</td><td>指定容器所在主机需要监听的端口号，默认跟上面 containerPort 相同，注意设置了 hostPort 同一台主机无法启动该容器的相同副本（因为主机的端口号不能相同，这样会冲突）</td></tr><tr><td>spec.containers[].ports[].protocol</td><td>string</td><td>指定端口协议，支持 TCP 和 UDP，默认值为 TCP</td></tr><tr><td>spec.containers[].env[]</td><td>list</td><td>指定容器运行前需设置的环境变量列表</td></tr><tr><td>spec.containers[].env[].name</td><td>string</td><td>指定环境变量名称</td></tr><tr><td>spec.containers[].env[].value</td><td>string</td><td>指定环境变量值</td></tr><tr><td>spec.containers[].resources</td><td>Object</td><td>指定资源限制和资源请求的值（这里开始就是设置容器的资源上限）</td></tr><tr><td>spec.containers[].resources.limits</td><td>Object</td><td>指定设置容器运行时资源的运行上限</td></tr><tr><td>spec.containers[].resources.limits.cpu</td><td>string</td><td>指定 CPU 的限制，单位为 Core 数，将用于 docker run –cpu-shares 参数</td></tr><tr><td>spec.containers[].resources.limits.memory</td><td>string</td><td>指定 mem 内存的限制，单位为 MIB、GiB</td></tr><tr><td>spec.containers[].resources.requests</td><td>Object</td><td>指定容器启动和调度时的限制设置</td></tr><tr><td>spec.containers[].resources.requests.cpu</td><td>string</td><td>CPU请求，单位为core数，容器启动时初始化可用数量</td></tr><tr><td>spec.containers[].resources.requests.memory</td><td>string</td><td>内存请求，单位为MIB、GiB，容器启动的初始化可用数量</td></tr><tr><td>spec.restartPolicy</td><td>string</td><td>定义 pod 的重启策略，可选值为 Always、OnFailure、Never，默认值为 Always。<br> - Always：pod 一旦终止运行，则无论容器是如何终止的，kubelet 服务都将重启它。<br> - OnFailure：只有 pod 以非零退出码终止时，kubelet 才会重启该容器。如果容器正常结束（退出码为0），则 kubectl 将不会重启它。<br> - Never：Pod 终止后，kubelet 将退出码报告给 master，不会重启该 pod</td></tr><tr><td>spec.nodeSelector</td><td>Object</td><td>定义 Node 的 label 过滤标签，以 key：value 格式指定</td></tr><tr><td>spec.imagePullSecrets</td><td>Object</td><td>定义 pull 镜像时使用 secret 名称，以 name：secretkey 格式指定</td></tr><tr><td>spec.hostNetwork</td><td>Boolean</td><td>定义是否使用主机网络模式，默认值为 false。设置 true 表示使用宿主机网络，不使用 docker 网桥，同时设置了 true将无法在同一台宿主机上启动第二个副本</td></tr></tbody></table>',2)]))}const p=d(s,[["render",o],["__file","00-k8s 的资源清单.html.vue"]]),l=JSON.parse('{"path":"/knowledge/Java/JavaEE/k8s/00-k8s%20%E7%9A%84%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95.html","title":"K8S 的资源清单","lang":"zh-CN","frontmatter":{"description":"K8S 的资源清单","head":[["meta",{"property":"og:url","content":"https://jishuzhaix.cn/knowledge/Java/JavaEE/k8s/00-k8s%20%E7%9A%84%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95.html"}],["meta",{"property":"og:site_name","content":"技数斋"}],["meta",{"property":"og:title","content":"K8S 的资源清单"}],["meta",{"property":"og:description","content":"K8S 的资源清单"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-17T14:21:20.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-17T14:21:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"K8S 的资源清单\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-17T14:21:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"贺墨于\\",\\"url\\":\\"https://jishuzhaix.cn\\"}]}"]]},"headers":[],"git":{"createdTime":1739802080000,"updatedTime":1739802080000,"contributors":[{"name":"HeMOu","username":"HeMOu","email":"fangqichenchao@163.com","commits":1,"url":"https://github.com/HeMOu"}]},"readingTime":{"minutes":3.08,"words":925},"filePathRelative":"knowledge/Java/JavaEE/k8s/00-k8s 的资源清单.md","localizedDate":"2025年2月17日","excerpt":"\\n<table>\\n<thead>\\n<tr>\\n<th>参数名</th>\\n<th>类型</th>\\n<th>字段说明</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>apiVersion</td>\\n<td>String</td>\\n<td>K8S APl 的版本，可以用 kubectl api versions 命令查询</td>\\n</tr>\\n<tr>\\n<td>kind</td>\\n<td>String</td>\\n<td>yam 文件定义的资源类型和角色</td>\\n</tr>\\n<tr>\\n<td>metadata</td>\\n<td>Object</td>\\n<td>元数据对象，下面是它的属性</td>\\n</tr>\\n<tr>\\n<td><a href=\\"http://metadata.name\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">metadata.name</a></td>\\n<td>String</td>\\n<td>元数据对象的名字，比如 pod 的名字</td>\\n</tr>\\n<tr>\\n<td>metadata.namespace</td>\\n<td>String</td>\\n<td>元数据对象的命名空间</td>\\n</tr>\\n<tr>\\n<td>Spec</td>\\n<td>Object</td>\\n<td>详细定义对象</td>\\n</tr>\\n<tr>\\n<td>spec.containers[]</td>\\n<td>list</td>\\n<td>定义 Spec 对象的容器列表</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].name</td>\\n<td>String</td>\\n<td>为列表中的某个容器定义名称</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].image</td>\\n<td>String</td>\\n<td>为列表中的某个容器定义需要的镜像名称</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].imagePullPolicy</td>\\n<td>string</td>\\n<td>定义镜像拉取策略，有 Always、Never、IfNotPresent 三个值可选<br>  - Always（默认）：意思是每次都尝试重新拉取镜像<br>  - Never：表示仅适用本地镜像<br>  - IfNotPresent：如果本地有镜像就使用本地镜像，没有就拉取在线镜像。</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].command[]</td>\\n<td>list</td>\\n<td>指定容器启动命令，因为是数组可以指定多个，不指定则使用镜像打包时使用的启动命令。</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].args[]</td>\\n<td>list</td>\\n<td>指定容器启动命令参数，因为是数组可以指定多个。</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].workingDir</td>\\n<td>string</td>\\n<td>指定容器的工作目录</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].volumeMounts[]</td>\\n<td>list</td>\\n<td>指定容器内部的存储卷配置</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].volumeMounts[].name</td>\\n<td>string</td>\\n<td>指定可以被容器挂载的存储卷的名称</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].volumeMounts[].mountPath</td>\\n<td>string</td>\\n<td>指定可以被容器挂载的存储卷的路径</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].volumeMounts[].readOnly</td>\\n<td>string</td>\\n<td>设置存储卷路径的读写模式，ture 或者 false，默认是读写模式</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].ports[]</td>\\n<td>list</td>\\n<td>指定容器需要用到的端口列表</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].ports[].name</td>\\n<td>string</td>\\n<td>指定端口的名称</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].ports[].containerPort</td>\\n<td>string</td>\\n<td>指定容器需要监听的端口号</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].ports[].hostPort</td>\\n<td>string</td>\\n<td>指定容器所在主机需要监听的端口号，默认跟上面 containerPort 相同，注意设置了 hostPort 同一台主机无法启动该容器的相同副本（因为主机的端口号不能相同，这样会冲突）</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].ports[].protocol</td>\\n<td>string</td>\\n<td>指定端口协议，支持 TCP 和 UDP，默认值为 TCP</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].env[]</td>\\n<td>list</td>\\n<td>指定容器运行前需设置的环境变量列表</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].env[].name</td>\\n<td>string</td>\\n<td>指定环境变量名称</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].env[].value</td>\\n<td>string</td>\\n<td>指定环境变量值</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].resources</td>\\n<td>Object</td>\\n<td>指定资源限制和资源请求的值（这里开始就是设置容器的资源上限）</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].resources.limits</td>\\n<td>Object</td>\\n<td>指定设置容器运行时资源的运行上限</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].resources.limits.cpu</td>\\n<td>string</td>\\n<td>指定 CPU 的限制，单位为 Core 数，将用于 docker run –cpu-shares 参数</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].resources.limits.memory</td>\\n<td>string</td>\\n<td>指定 mem 内存的限制，单位为 MIB、GiB</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].resources.requests</td>\\n<td>Object</td>\\n<td>指定容器启动和调度时的限制设置</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].resources.requests.cpu</td>\\n<td>string</td>\\n<td>CPU请求，单位为core数，容器启动时初始化可用数量</td>\\n</tr>\\n<tr>\\n<td>spec.containers[].resources.requests.memory</td>\\n<td>string</td>\\n<td>内存请求，单位为MIB、GiB，容器启动的初始化可用数量</td>\\n</tr>\\n<tr>\\n<td>spec.restartPolicy</td>\\n<td>string</td>\\n<td>定义 pod 的重启策略，可选值为 Always、OnFailure、Never，默认值为 Always。<br>  - Always：pod 一旦终止运行，则无论容器是如何终止的，kubelet 服务都将重启它。<br>  - OnFailure：只有 pod 以非零退出码终止时，kubelet 才会重启该容器。如果容器正常结束（退出码为0），则 kubectl 将不会重启它。<br>  - Never：Pod 终止后，kubelet 将退出码报告给 master，不会重启该 pod</td>\\n</tr>\\n<tr>\\n<td>spec.nodeSelector</td>\\n<td>Object</td>\\n<td>定义 Node 的 label 过滤标签，以 key：value 格式指定</td>\\n</tr>\\n<tr>\\n<td>spec.imagePullSecrets</td>\\n<td>Object</td>\\n<td>定义 pull 镜像时使用 secret 名称，以 name：secretkey 格式指定</td>\\n</tr>\\n<tr>\\n<td>spec.hostNetwork</td>\\n<td>Boolean</td>\\n<td>定义是否使用主机网络模式，默认值为 false。设置 true 表示使用宿主机网络，不使用 docker 网桥，同时设置了 true将无法在同一台宿主机上启动第二个副本</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}');export{p as comp,l as data};
